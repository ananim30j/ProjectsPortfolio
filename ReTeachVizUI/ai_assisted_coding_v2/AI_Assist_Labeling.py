# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/AI_Assist_Labeling.ipynb.

# %% auto 0
__all__ = ['BertBase', 'CsvLabeler']

# %% ../nbs/AI_Assist_Labeling.ipynb 3
# Importing necessary libraries
import pandas as pd
from transformers import pipeline, BertTokenizer, BertForSequenceClassification

# %% ../nbs/AI_Assist_Labeling.ipynb 4
# Define class
class BertBase:
    # Takes 3 parameters
    # model_name defaults to bert-based-uncased, pre-trained BERT model provided by hugging face
    def __init__(self, model_name="bert-base-uncased", load_model_path=None, dataframe=None):
        print('BertBase is being initialized')
        
        # Mapping from descriptive labels to acronyms
        self.label_map = {
            "An opportunity to respond": "OTR",
            "Praise": "PRS",
            "Reprimand": "REP",
            "None of the above": "NEU"
        }
        # If dataframe not provided, set to none
        # Otherwise CSV file is read into pandas dataframe and assigns it here
        self.df = pd.read_csv(dataframe) if dataframe else None

        # Load the model from the specified path if provided, otherwise load a pretrained model
        if load_model_path:
            self.model = BertForSequenceClassification.from_pretrained(load_model_path, num_labels=len(self.label_map))
            self.tokenizer = BertTokenizer.from_pretrained(load_model_path)
        else:
            self.model = BertForSequenceClassification.from_pretrained(model_name, num_labels=len(self.label_map))
            self.tokenizer = BertTokenizer.from_pretrained(model_name)

        # Initializing a zero-shot classification pipeline with the model and tokenizer
        self.classifier = pipeline("zero-shot-classification", model=self.model, tokenizer=self.tokenizer)


# %% ../nbs/AI_Assist_Labeling.ipynb 6
class CsvLabeler(BertBase):
    def label_csv(self, file_name, output_filename='../labeled_data/labeled_classroom_transcripts.csv'):
        # Load data from the CSV file
        df = pd.read_csv(file_name)
        
        # Ensure 'Label' and 'Confidence' columns exist and are of type 'object' and 'float' respectively
        if 'Label' not in df.columns:
            df['Label'] = pd.Series(dtype='object')
        else:
            df['Label'] = df['Label'].astype('object')
        if 'Confidence' not in df.columns:
            df['Confidence'] = pd.Series(dtype='float')

        # Prepare descriptive labels for classification
        descriptive_labels = list(self.label_map.keys())
        
        # Classify each row in the dataframe and assign labels
        for index, row in df.iterrows():
            result = self.classifier(row['Text'], descriptive_labels)
            # Convert descriptive label to acronym and store it along with confidence
            df.at[index, 'Label'] = self.label_map[result['labels'][0]]
            df.at[index, 'Confidence'] = result['scores'][0]

        # Save the labeled data to a CSV file
        df.to_csv(output_filename, index=False)
        return output_filename

    def colorize_confidence(self, dataframe):
        """
        Apply color formatting to the dataframe based on confidence scores.
        High confidence: Green, Medium: White, Low: Red.
        """
        def apply_color(val):
            color = 'yellow'
            if val >= 0.75:
                color = 'green'
            elif val <= 0.25:
                color = 'red'
            return f'background-color: {color}'

        return dataframe.style.applymap(apply_color, subset=['Confidence'])

